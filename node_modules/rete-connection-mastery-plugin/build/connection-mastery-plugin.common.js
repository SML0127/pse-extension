/*!
* rete-connection-mastery-plugin v0.2.3 
* (c) 2019 Vitaliy Stoliarov 
* Released under the MIT license.
*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var rete = require('rete');

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function holdKey(keyCode) {
  var holding = false;

  var keydown = function keydown(e) {
    if (e.code === keyCode) holding = true;
  };

  var keyup = function keyup(e) {
    if (e.code === keyCode) holding = false;
  };

  document.addEventListener('keydown', keydown);
  document.addEventListener('keyup', keyup);
  return {
    get holding() {
      return holding;
    },

    destroy: function destroy() {
      document.removeEventListener('keydown', keydown);
      document.removeEventListener('keydown', keyup);
    }
  };
}

/// <reference types="rete-connection-plugin" />
function initializeCreateAndConnect (editor, keyCode) {
  var holder = holdKey(keyCode);
  var mouseEvent = null;
  var targetIO = null;
  editor.view.container.addEventListener('mousemove', function (e) {
    mouseEvent = e;
  });
  editor.on('connectiondrop', function (io) {
    if (!mouseEvent) throw 'Error not found';
    if (!holder.holding) return;
    targetIO = io;
    editor.trigger('contextmenu', {
      e: mouseEvent
    });
  });
  editor.on('nodecreated', function (node) {
    if (!holder.holding) return;
    var io = targetIO;

    if (io instanceof rete.Output) {
      var inputs = Array.from(node.inputs.values());
      var compatibleInput = inputs.find(function (i) {
        return io.socket.compatibleWith(i.socket);
      });

      if (compatibleInput) {
        if (!compatibleInput.multipleConnections && compatibleInput.hasConnection()) editor.removeConnection(compatibleInput.connections[0]);
        if (!io.multipleConnections && io.hasConnection()) editor.removeConnection(io.connections[0]);
        editor.connect(io, compatibleInput);
      }
    } else if (io instanceof rete.Input) {
      var outputs = Array.from(node.outputs.values());
      var compatibleOutput = outputs.find(function (o) {
        return o.socket.compatibleWith(io.socket);
      });

      if (compatibleOutput) {
        if (!compatibleOutput.multipleConnections && compatibleOutput.hasConnection()) editor.removeConnection(compatibleOutput.connections[0]);
        editor.connect(compatibleOutput, io);
      }
    }
  });
  editor.on('destroy', function () {
    return holder.destroy();
  });
}

var style = 'fill: none; stroke-width: 15px; stroke: transparent;';
function initializePickConnection (editor, keyCode) {
  var holder = holdKey(keyCode);
  editor.on('renderconnection', function (_ref) {
    var el = _ref.el,
        connection = _ref.connection;
    var mainPath = el.querySelector('path');
    var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('style', style);
    path.setAttribute('id', 'pick');
    path.addEventListener('click', function () {
      return holder.holding && editor.removeConnection(connection);
    });

    if (mainPath && mainPath.parentElement) {
      path.setAttribute('d', mainPath.getAttribute('d') || '');
      mainPath.parentElement.appendChild(path);
    }
  });
  editor.on('updateconnection', function (_ref2) {
    var el = _ref2.el;
    var mainPath = el.querySelector('path');
    var path = el.querySelector('#pick');
    if (mainPath && path) path.setAttribute('d', mainPath.getAttribute('d') || '');
  });
}

function install(editor, params) {
  var createAndConnect = params.createAndConnect === false ? false : params.createAndConnect || {
    keyCode: 'Control'
  };
  var pickConnection = params.pickConnection === false ? false : params.pickConnection || {
    keyCode: 'KeyD'
  };
  if (_typeof(createAndConnect) === 'object') initializeCreateAndConnect(editor, createAndConnect.keyCode);
  if (_typeof(pickConnection) === 'object') initializePickConnection(editor, pickConnection.keyCode);
}

var index = {
  name: 'connection-mastery',
  install: install
};

exports.default = index;
//# sourceMappingURL=connection-mastery-plugin.common.js.map
